generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [pgvector(map: "vector"), pg_trgm]
}

// ============================================================================
// USERS & AUTH
// ============================================================================

model User {
  id           String   @id @default(cuid())
  email        String   @unique
  passwordHash String   @map("password_hash")
  name         String?
  avatarUrl    String?  @map("avatar_url")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  // Relations
  ownedDocuments Document[]       @relation("DocumentOwner")
  memberships    DocumentMember[]
  annotations    Annotation[]

  @@map("users")
}

// ============================================================================
// DOCUMENTS
// ============================================================================

enum DocumentType {
  PDF
  IMAGE
  CODE
  TEXT
  MARKDOWN
}

model Document {
  id          String       @id @default(cuid())
  ownerId     String       @map("owner_id")
  title       String
  type        DocumentType
  mimeType    String       @map("mime_type")
  size        Int // bytes
  s3Key       String       @map("s3_key")
  version     Int          @default(1)
  textContent String?      @map("text_content") // extracted text for search
  createdAt   DateTime     @default(now()) @map("created_at")
  updatedAt   DateTime     @updatedAt @map("updated_at")

  // Relations
  owner       User             @relation("DocumentOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  members     DocumentMember[]
  annotations Annotation[]

  // Embedding for semantic search (1536 dimensions for OpenAI ada-002)
  // Uncomment when ready to use embeddings:
  // embedding Unsupported("vector(1536)")?

  @@index([ownerId])
  @@index([type])
  @@map("documents")
}

// Join table for users who have access to a document
model DocumentMember {
  id         String   @id @default(cuid())
  documentId String   @map("document_id")
  userId     String   @map("user_id")
  joinedAt   DateTime @default(now()) @map("joined_at")

  // Relations
  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Each user can only be a member once per document
  @@unique([documentId, userId])
  @@index([userId])
  @@map("document_members")
}

// ============================================================================
// ANNOTATIONS
// ============================================================================

enum AnnotationType {
  HIGHLIGHT
  COMMENT
  INLINE_NOTE
  LINK
  TAG
}

enum AnnotationLayer {
  PERSONAL
  GROUP
  PUBLIC
}

model Annotation {
  id         String          @id @default(cuid())
  documentId String          @map("document_id")
  userId     String          @map("user_id")
  type       AnnotationType
  layer      AnnotationLayer @default(PERSONAL)

  // Hybrid anchor - stored as JSON, structure varies by document type
  // For PDF/images: { type: "coords", page, x, y, width, height, text?: { selected, before, after } }
  // For code: { type: "code", startLine, endLine, startCol?, endCol?, snippet }
  // For text: { type: "text", startOffset, endOffset, selected, before, after }
  anchor Json

  // Content
  color    String? // hex color for highlights
  content  String? // comment text, note text, tag label
  parentId String? @map("parent_id") // for threading

  // Thread state
  resolved Boolean @default(false)

  // Flexible metadata (reactions, AI citations, etc.)
  metadata Json?

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  document Document    @relation(fields: [documentId], references: [id], onDelete: Cascade)
  user     User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  parent   Annotation? @relation("AnnotationThread", fields: [parentId], references: [id], onDelete: Cascade)
  replies  Annotation[] @relation("AnnotationThread")

  // Embedding for semantic search on annotation content
  // Uncomment when ready to use embeddings:
  // embedding Unsupported("vector(1536)")?

  @@index([documentId])
  @@index([userId])
  @@index([documentId, layer])
  @@index([parentId])
  @@map("annotations")
}
